/*
YCloud API

The [YCloud](https://ycloud.com) API is organized around [REST](https://en.wikipedia.org/wiki/Representational_state_transfer). Our API is designed to have predictable, resource-oriented URLs, return [JSON](https://www.json.org) responses, and use standard HTTP response codes and verbs.

API version: v2
Contact: service@ycloud.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ycloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// WhatsappFlowsApiService WhatsappFlowsApi service
type WhatsappFlowsApiService service

type WhatsappFlowsApiCreateRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	whatsappFlowCreateRequest *WhatsappFlowCreateRequest
}

func (r WhatsappFlowsApiCreateRequest) WhatsappFlowCreateRequest(whatsappFlowCreateRequest WhatsappFlowCreateRequest) WhatsappFlowsApiCreateRequest {
	r.whatsappFlowCreateRequest = &whatsappFlowCreateRequest
	return r
}

func (r WhatsappFlowsApiCreateRequest) Execute() (*WhatsappFlowCreate200Response, *http.Response, error) {
	return r.ApiService.CreateExecute(r)
}

/*
Create Create a flow

Creates a new WhatsApp Flow. New Flows are by default created in DRAFT state. You can create a new published Flow in single request by specifying flowJson and publish parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return WhatsappFlowsApiCreateRequest
*/
func (a *WhatsappFlowsApiService) Create(ctx context.Context) WhatsappFlowsApiCreateRequest {
	return WhatsappFlowsApiCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WhatsappFlowCreate200Response
func (a *WhatsappFlowsApiService) CreateExecute(r WhatsappFlowsApiCreateRequest) (*WhatsappFlowCreate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowCreate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.Create")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.whatsappFlowCreateRequest == nil {
		return localVarReturnValue, nil, reportError("whatsappFlowCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsappFlowCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsappFlowCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiDeleteRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
}

func (r WhatsappFlowsApiDeleteRequest) Execute() (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Delete a flow

Deletes a WhatsApp Flow. Only Flows in DRAFT status can be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiDeleteRequest
*/
func (a *WhatsappFlowsApiService) Delete(ctx context.Context, flowId string) WhatsappFlowsApiDeleteRequest {
	return WhatsappFlowsApiDeleteRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlowUpdateMetadata200Response
func (a *WhatsappFlowsApiService) DeleteExecute(r WhatsappFlowsApiDeleteRequest) (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowUpdateMetadata200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.Delete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiDeprecateRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
}

func (r WhatsappFlowsApiDeprecateRequest) Execute() (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	return r.ApiService.DeprecateExecute(r)
}

/*
Deprecate Deprecate a flow

Marks a published Flow as deprecated. Once a Flow is published, it cannot be modified or deleted, but can be marked as deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiDeprecateRequest
*/
func (a *WhatsappFlowsApiService) Deprecate(ctx context.Context, flowId string) WhatsappFlowsApiDeprecateRequest {
	return WhatsappFlowsApiDeprecateRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlowUpdateMetadata200Response
func (a *WhatsappFlowsApiService) DeprecateExecute(r WhatsappFlowsApiDeprecateRequest) (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowUpdateMetadata200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.Deprecate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}/deprecate"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiListRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	wabaId *string
}

// WhatsApp Business Account ID.
func (r WhatsappFlowsApiListRequest) WabaId(wabaId string) WhatsappFlowsApiListRequest {
	r.wabaId = &wabaId
	return r
}

func (r WhatsappFlowsApiListRequest) Execute() (*WhatsappFlowList200Response, *http.Response, error) {
	return r.ApiService.ListExecute(r)
}

/*
List List flows

Returns a list of WhatsApp Flows under a WhatsApp Business Account (WABA).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return WhatsappFlowsApiListRequest
*/
func (a *WhatsappFlowsApiService) List(ctx context.Context) WhatsappFlowsApiListRequest {
	return WhatsappFlowsApiListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WhatsappFlowList200Response
func (a *WhatsappFlowsApiService) ListExecute(r WhatsappFlowsApiListRequest) (*WhatsappFlowList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.List")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wabaId == nil {
		return localVarReturnValue, nil, reportError("wabaId is required and must be specified")
	}

	localVarQueryParams.Add("wabaId", parameterToString(*r.wabaId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiPreviewRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
	invalidate *bool
}

// the link will expire in 30 days in default, or if you set with invalidate&#x3D;true which will generate a new link.
func (r WhatsappFlowsApiPreviewRequest) Invalidate(invalidate bool) WhatsappFlowsApiPreviewRequest {
	r.invalidate = &invalidate
	return r
}

func (r WhatsappFlowsApiPreviewRequest) Execute() (*WhatsappFlowPreviewUrl, *http.Response, error) {
	return r.ApiService.PreviewExecute(r)
}

/*
Preview generate a web preview URL with this flow.

In order to visualize the Flows created, you can generate a web preview URL with this request. **The preview URL is public and can be shared with different stakeholders to visualize the Flow.**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiPreviewRequest
*/
func (a *WhatsappFlowsApiService) Preview(ctx context.Context, flowId string) WhatsappFlowsApiPreviewRequest {
	return WhatsappFlowsApiPreviewRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlowPreviewUrl
func (a *WhatsappFlowsApiService) PreviewExecute(r WhatsappFlowsApiPreviewRequest) (*WhatsappFlowPreviewUrl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowPreviewUrl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.Preview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.invalidate != nil {
		localVarQueryParams.Add("invalidate", parameterToString(*r.invalidate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiPublishRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
}

func (r WhatsappFlowsApiPublishRequest) Execute() (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	return r.ApiService.PublishExecute(r)
}

/*
Publish Publish a flow

Updates the status of the Flow to "PUBLISHED". You can either edit this flow in the future and turn it back to the "DRAFT" state, or create a new flow by specifying the existing Flow ID as the cloneFlowId parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiPublishRequest
*/
func (a *WhatsappFlowsApiService) Publish(ctx context.Context, flowId string) WhatsappFlowsApiPublishRequest {
	return WhatsappFlowsApiPublishRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlowUpdateMetadata200Response
func (a *WhatsappFlowsApiService) PublishExecute(r WhatsappFlowsApiPublishRequest) (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowUpdateMetadata200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.Publish")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiRetrieveRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
}

func (r WhatsappFlowsApiRetrieveRequest) Execute() (*WhatsappFlow, *http.Response, error) {
	return r.ApiService.RetrieveExecute(r)
}

/*
Retrieve Retrieve a flow

Retrieves a WhatsApp Flow's details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiRetrieveRequest
*/
func (a *WhatsappFlowsApiService) Retrieve(ctx context.Context, flowId string) WhatsappFlowsApiRetrieveRequest {
	return WhatsappFlowsApiRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlow
func (a *WhatsappFlowsApiService) RetrieveExecute(r WhatsappFlowsApiRetrieveRequest) (*WhatsappFlow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.Retrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiUpdateMetadataRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
	whatsappFlowUpdateMetadataRequest *WhatsappFlowUpdateMetadataRequest
}

func (r WhatsappFlowsApiUpdateMetadataRequest) WhatsappFlowUpdateMetadataRequest(whatsappFlowUpdateMetadataRequest WhatsappFlowUpdateMetadataRequest) WhatsappFlowsApiUpdateMetadataRequest {
	r.whatsappFlowUpdateMetadataRequest = &whatsappFlowUpdateMetadataRequest
	return r
}

func (r WhatsappFlowsApiUpdateMetadataRequest) Execute() (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	return r.ApiService.UpdateMetadataExecute(r)
}

/*
UpdateMetadata Update flow metadata

Updates a WhatsApp Flow's metadata (name or categories).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiUpdateMetadataRequest
*/
func (a *WhatsappFlowsApiService) UpdateMetadata(ctx context.Context, flowId string) WhatsappFlowsApiUpdateMetadataRequest {
	return WhatsappFlowsApiUpdateMetadataRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlowUpdateMetadata200Response
func (a *WhatsappFlowsApiService) UpdateMetadataExecute(r WhatsappFlowsApiUpdateMetadataRequest) (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowUpdateMetadata200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.UpdateMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.whatsappFlowUpdateMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("whatsappFlowUpdateMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsappFlowUpdateMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WhatsappFlowsApiUpdateStructureRequest struct {
	ctx context.Context
	ApiService *WhatsappFlowsApiService
	flowId string
	flowJson **os.File
}

// JSON file containing the Flow structure.
func (r WhatsappFlowsApiUpdateStructureRequest) FlowJson(flowJson *os.File) WhatsappFlowsApiUpdateStructureRequest {
	r.flowJson = &flowJson
	return r
}

func (r WhatsappFlowsApiUpdateStructureRequest) Execute() (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	return r.ApiService.UpdateStructureExecute(r)
}

/*
UpdateStructure Update flow structure

Updates a WhatsApp Flow's structure. Note that the file must be attached as form-data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowId Flow ID.
 @return WhatsappFlowsApiUpdateStructureRequest
*/
func (a *WhatsappFlowsApiService) UpdateStructure(ctx context.Context, flowId string) WhatsappFlowsApiUpdateStructureRequest {
	return WhatsappFlowsApiUpdateStructureRequest{
		ApiService: a,
		ctx: ctx,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return WhatsappFlowUpdateMetadata200Response
func (a *WhatsappFlowsApiService) UpdateStructureExecute(r WhatsappFlowsApiUpdateStructureRequest) (*WhatsappFlowUpdateMetadata200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WhatsappFlowUpdateMetadata200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhatsappFlowsApiService.UpdateStructure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/flows/{flowId}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.flowJson == nil {
		return localVarReturnValue, nil, reportError("flowJson is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var flowJsonLocalVarFormFileName string
	var flowJsonLocalVarFileName     string
	var flowJsonLocalVarFileBytes    []byte

	flowJsonLocalVarFormFileName = "flowJson"

	flowJsonLocalVarFile := *r.flowJson
	if flowJsonLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(flowJsonLocalVarFile)
		flowJsonLocalVarFileBytes = fbs
		flowJsonLocalVarFileName = flowJsonLocalVarFile.Name()
		flowJsonLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: flowJsonLocalVarFileBytes, fileName: flowJsonLocalVarFileName, formFileName: flowJsonLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsappFlowCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
